<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: SICP | Chao's Random Thoughts]]></title>
  <link href="http://chuchao333.github.com/blog/tags/sicp/atom.xml" rel="self"/>
  <link href="http://chuchao333.github.com/"/>
  <updated>2013-06-24T23:50:28+08:00</updated>
  <id>http://chuchao333.github.com/</id>
  <author>
    <name><![CDATA[Chao Chu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SICP Section 1.2]]></title>
    <link href="http://chuchao333.github.com/blog/2013/06/14/sicp-section-1-2/"/>
    <updated>2013-06-14T00:54:00+08:00</updated>
    <id>http://chuchao333.github.com/blog/2013/06/14/sicp-section-1-2</id>
    <content type="html"><![CDATA[<p>Recursive Process V.S. Iterative Process
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>

<ul>
  <li>
    <p>Recursive process</p>

    <p>The substitution model of a recursive process reveals a shape of expansion
followed by constraction. The expansion occurs as the process builds up a
chain of defered operations. The contraction occurs as the operations are
actually performed.</p>
  </li>
  <li>
    <p>Iterative process</p>

    <p>An iterative process is one whose state can be summarized by a fixed number
of state variables, together with a fixed rule that describes how the state
variables should be updated as the process moves from state to state and an
(optional) end test that specifies the conditions under which the process
should terminate.</p>
  </li>
</ul>

<p>In the iterative case, the program variables provide a complete description
of the state of the process at any point, while in the recursive case, there
is some additional “hidden” information, maintained by the interpreter and not
contained in the program variables.</p>

<p>.. highlights::</p>

<pre><code>In contrasting iteration and recursion, we must be careful not to confuse
the notion of a recursive process with the notion of a recursive procedure.
When we describe a procedure as recursive, we are referring to the
syntactic fact that the procedure definition refers (either directly or
indirectly) to the procedure itself. But when we describe a process as
following a pattern that is, say, linearly recursive, we are speaking about
how the process evolves, not about the syntax of how a procedure is written.
It may seem disturbing that we refer to a recursive procedure as generating
an iterative process.
</code></pre>

<p>Lame’s Theorem
~~~~~~~~~~~~~~</p>

<p>.. highlights::</p>

<pre><code>If Euclid's Algorithm requires k steps to compute the GCD of some pair,
then the smaller number in the pair must be greater than or equal to the
kth Fibonacci number.
</code></pre>

<p>Fermat’s Little Theorem
~~~~~~~~~~~~~~~~~~~~~~~</p>

<p>.. highlights::</p>

<pre><code>If n is a prime number and a is any positive integer less than n, then a
raised to the nth power is congruent to a modulo n.
</code></pre>

<p>Exercises
~~~~~~~~~</p>

<p><strong>1.9</strong>
Answer: The first process is recursive and the second one is iterative.</p>

<p><strong>1.10</strong>
Answer: from the definition of (A x y), we have:</p>

<p>(A 1 10) = A(0 (A 1 9)) = 2 * (A 1 9) = … = 2^9 * (A 1 1) = 2^10</p>

<p>(A 2 4) = 65536</p>

<p>(A 3 3) = 65536</p>

<p>(f n) computes <em>2n</em></p>

<p>(g n) computes <em>2^n</em></p>

<p>(h n) computes <em>2^2^2… (n times)</em></p>

<p><strong>1.11</strong>
Answer: This is similar with the example of computing Fibonacci number.</p>

<p>.. code-block:: scheme</p>

<pre><code>(define (f-recursive n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        ((= n 2) 2)
        (else (+ (f-recursive (- n 1))
                 (* (f-recursive (- n 2)) 2)
                 (* (f-recursive (- n 3)) 3)))))


(define (f-iterative n)
  (f-iter 0 1 2 n))

(define (f-iter a b c count)
  (cond ((= count 0) a)
        ((= count 1) b)
        ((= count 2) c)
        (else (f-iter b c (+ c (* b 2) (* a 3)) (- count 1)))))
</code></pre>

<p><strong>1.12</strong></p>

<p>.. code-block:: scheme</p>

<pre><code>; both row and col indexes start at 0
(define (pascal-triangle row col)
  (cond ((= col 0) 1)
        ((= row col) 1)
        (else (+ (pascal-triangle (- row 1) (- col 1))
                 (pascal-triangle (- row 1) col)))))
</code></pre>

<p><strong>1.15</strong>
Answer:</p>

<p>a. from the the procedure definition, suppose <em>p</em> will be called t times,
we have:</p>

<p>a / (3^t) &lt;= 0.1, which leads to:</p>

<p>log(10a) &lt;= t, so t = ceiling (log(10a)) = 5, (the base of the log is 3)</p>

<p>b. both the space and number of steps depend on how many times <em>p</em> is called,
so it’s O(t) = O(log(a)).</p>

<p><strong>1.16</strong></p>

<p>.. code-block:: scheme</p>

<pre><code>(define (fast-expt b n)
  (fast-expt-iter b n 1))

(define (fast-expt-iter b n product)
  (cond ((= n 0) product)
        ((even? n) (fast-expt-iter (square b) (/ n 2) product))
        (else (fast-expt-iter b (- n 1) (* b product)))))

(define (square x) (* x x))

(define (even? n)
  (= (remainder n 2) 0))
</code></pre>

<p><strong>1.17</strong></p>

<p>.. code-block:: scheme</p>

<pre><code>(define (mul a b)
  (cond ((= b 0) 0)
        ((even? b) (mul (double a) (halve b)))
        (else (+ a (mul a (- b 1))))))

(define (double x) (* x 2))
(define (halve x) (/ x 2))
</code></pre>

<p><strong>1.18</strong></p>

<p>.. code-block:: scheme</p>

<pre><code>(define (mul a b)
  (mul-iter a b 0))

(define (mul-iter a b sum)
  (cond ((= b 0) sum)
        ((even? b) (mul-iter (double a) (halve b) sum))
        (else (mul-iter a (- b 1) (+ a sum)))))


(define (double x) (* x 2))
(define (halve x) (/ x 2))
</code></pre>

<p><strong>1.19</strong></p>

<p>.. code-block:: scheme</p>

<pre><code>; use the matrix multiplication to represent the transformation

;                       0 1
; (fib(n-1), fib(n)) *        = (fib(n), fib(n-1) + fib(n)) = (fib(n), fib(n+1))
;                       1 1

; a &lt;- a + b
; b &lt;- a

; the state transformation above is just a special case of the below one when
; p = 0 and q = 1

; a &lt;- bq + aq + ap
; b &lt;- bp + aq

(define (fib n)
  (fib-iter 1 0 0 1 n))

(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter
           a
           b
           (+ (square p) (square q))
           (+ (square q) (* p q 2))
           (/ count 2)))
  (else (fib-iter
          (+ (* b q) (* a q) (* a p))
          (+ (* b p) (* a q))
          p
          q
          (- count 1)))))

(define (square x) (* x x))
</code></pre>

<p><strong>1.21</strong></p>

<p>.. code-block:: scheme</p>

<pre><code>; the following expressions produce
; 199
; 1999
; 7

(smallest-divisor 199)
(smallest-divisor 1999)
(smallest-divisor 19999)
</code></pre>

<p><strong>1.25</strong>
Answer:</p>

<p>Since <em>Scheme</em> has built-in support for arbitrary precision arithmetic, the
procedure will produce the same result as the original <em>expmod</em>, however,
it will be very inefficient since the huge number arithmetic will take much
longer time than the numbers can be represented by a single computer word.</p>

<p>The original <em>expmod</em> used the successive squaring, the numbers to be processed
will never be larger than m^2.</p>

<p><strong>1.26</strong>
Answer:</p>

<p>With the calling of <em>square</em>, the original problem can be reduced to a sub
problem with half of the size at each of the step when even? test is true.
So T(n) = T(n/2) = O(logn)</p>

<p>However, if the explicit multiplication used instead, the recursive call
of expmod will be evaluated twice, it not only just compute the sub
problems two time, it is actually a tree recursion like the first solution
for computing fibnacci sequence, so the number of expmod calls grow
exponentially, which conclues that T(n) = O(2^n * logn) = O(n)</p>

<p><strong>1.27</strong></p>

<p>.. code-block:: scheme</p>

<pre><code>(define (fermat-test n)
  (fermat-test-iter n 2))

(define (fermat-test-iter n a)
  (cond ((= n a) true)
        ((not (= (expmod a n n) a)) false)
        (else (fermat-test-iter n (+ a 1)))))

(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (square (expmod base (/ exp 2) m)) m))
        (else (remainder (* base (expmod base (- exp 1) m)) m))))

(define (square x) (* x x))


; Carmichael numbers
(fermat-test 561)
(fermat-test 1105)
(fermat-test 1729)
(fermat-test 2465)
(fermat-test 2821)
(fermat-test 6601)
; these all give #t

(prime? 561)
(prime? 1105)
(prime? 1729)
(prime? 2465)
(prime? 2821)
(prime? 6601)
; these all give #f
</code></pre>

<p><strong>1.28</strong></p>

<p>.. code-block:: scheme</p>

<pre><code>(define (miller-rabin-test n)
  (define (try-it a)
    (= (expmod-with-signal a (- n 1) n) 1))
  (try-it (+ 2 (random (- n 2)))))

(define (expmod-with-signal base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (square-with-signal (expmod-with-signal base (/ exp 2) m) m))
        (else 
         (remainder (* base (expmod-with-signal base (- exp 1) m)) m))))

(define (square-with-signal a n)
  (if (and (not (= a 1))
           (not (= a (- n 1)))
           (= (remainder (* a a) n) 1))
      0
      (remainder (* a a) n)))


(miller-rabin-test 561)
(miller-rabin-test 1105)
(miller-rabin-test 1729)
(miller-rabin-test 2465)
(miller-rabin-test 2821)
(miller-rabin-test 6601)
; these will all give #f with quite a chance, but with enough runs, it will
; have some false positive

(newline)

(miller-rabin-test 7)
(miller-rabin-test 23)
(miller-rabin-test 103)
(miller-rabin-test 1009)
(miller-rabin-test 1019)
(miller-rabin-test 1000033)
; these will always all give #t
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SICP Section 1.1]]></title>
    <link href="http://chuchao333.github.com/blog/2013/05/14/sicp-section-1-1/"/>
    <updated>2013-05-14T00:39:00+08:00</updated>
    <id>http://chuchao333.github.com/blog/2013/05/14/sicp-section-1-1</id>
    <content type="html"><![CDATA[<p>.. highlights::</p>

<pre><code>Computational processes are abstract beings that inhabit computers. As they
evolve, processes manipulate other abstract things called data. The evolution
of a process is directed by pattern of rules called a program.
</code></pre>

<p>Why use Lisp for the book?</p>

<p>.. highlights::</p>

<pre><code>The most significant unique feature of Lisp is the fact that Lisp descriptions
of processes, called procedures, can themselves be represented and manipulated
as Lisp data. The importance of this is that there are powerful program-design
techniques that rely on the ability to blur the traditional distinction between
"passive" data and "active" processes.
</code></pre>

<p>The three mechanisms of combining simple ideas to form more complex ideas in any
powerful programming languages:</p>

<ol>
  <li>primitive expressions
#. means of combination
#. means of abstraction</li>
</ol>

<p>Substitution model
~~~~~~~~~~~~~~~~~~</p>

<ul>
  <li>
    <p>Applicative order</p>

    <p>Evaluate the operator and operands first and then applies the resulting procedure
to the resulting arguments. “Fully expand and then reduce”</p>
  </li>
  <li>
    <p>Normal order</p>

    <p>Don’t evaluate the operands until their values are needed, instead, substitute
operand expressions for parameters until it obtained an expression involving only
primitive operators, and would then perform the evaluation. “Evaluate the
arguments and then apply”</p>
  </li>
</ul>

<p>Example: Square Roots by Newton’s Method
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>

<p>.. highlights::</p>

<pre><code>The contrast between function and procedure is a reflection of the general
distinction between describing properties of things and describing how to
do things, or, as it is sometimes refered to, the distinction between
declarative knowledge and imperative knowledge. In mathematics we are
usually concerned with declarative (what is) descriptions, whereas in
computer science we are usually concerned with imperative (how to)
descriptions.
</code></pre>

<p>Exercises
~~~~~~~~~</p>

<p><strong>1.3</strong> Define a procedure that takes three numbers as arguments and return the
sum of squares of the two larger numbers.</p>

<p>.. code-block:: scheme</p>

<pre><code>(define (square x) (* x x))

(define (sum-of-squares a b) (+ (square a) (square b)))

(define (min a b)
  (if (&lt; a b)
     a
     b))

(define (max a b)
  (if (&lt; a b)
     b
     a))

(define (sum-of-squares-of-2-largest a b c)
  (sum-of-squares (max a b) (max c (min a b))))
</code></pre>

<p><strong>1.4</strong> Observe that our model of evaluation allows for combinations whose
operators are compound expressions. Use this observation to describe the
behavior of the following procedure:</p>

<p>.. code-block:: scheme</p>

<pre><code>(define (a-plus-abs-b a b)
  ((if (&gt; b 0) + -) a b))
</code></pre>

<p>if b is greater than 0, the operator that will apply to a and b is +, or else
it will be -, so the a-plus-abs-b will always result in a plus abs of b.</p>

<p><strong>1.5</strong>
Answer: the interpreter that uses applicative order evaluation will hang due
to the infinite recursive call of ‘p’, while an interpreter that uses normal
order evaluation will get 0.</p>

<p><em>Note:</em> <strong>p</strong> is a function, <strong>(p)</strong> is a call to function p.</p>

<p><strong>1.6</strong>
Answer: the interpreter will hang due to the infinite recursive call to
<em>sqrt-iter</em>. Since List uses applicative order evaluation, in the definition
of new-if, the else-clause will always be evaluated no matter the result of
the predicate, thus lead to infinite recursive call to sqrt-iter. That’s why
<strong>if</strong> needs to be a special form, the predicate expression is evaluated first,
and the result determines whether to evaluate the consequent or the alternative
expression.</p>

<p><strong>1.7</strong>
Answer: For small values, the absolute tolerance 0.001 is too large, so the
results become inaccurate. For example, (sqrt 0.001) gives 0.04124542607499115
on my machine. (ubuntu 12.10 x86_64); And for large values, due to the precision
limitation of float-point representation, the guess couldn’t be refined to a
value that can be represented within the tolerance. In such cases, the program
can endlessly alternate between two guesses that are more than 0.001 away from
the true square root.</p>

<p>so, instead of using absolute tolerance, we changed to use the relative
tolerance of two continuous guess values. This can be demonstrated with the
below updated good-enough? procedure:</p>

<p>.. code-block:: scheme</p>

<pre><code>(define (good-enough? guess x)
  (&lt; (abs (- (improve guess x) guess)) 0.001))
</code></pre>

<p><strong>1.8</strong></p>

<p>.. code-block:: scheme</p>

<pre><code>(define (cbrt-iter guess x)
  (if (good-enough? guess x)
    guess
    (cbrt-iter (improve guess x) x)))

(define (improve guess x)
  (/ (+ (/ x (square guess)) (* 2 guess)) 3))

(define (good-enough? guess x)
  (&lt; (abs (- (improve guess x) guess)) 0.001))

(define (square x)
  (* x x))

(define (cbrt x)
  (cbrt-iter 1.0 x))
</code></pre>

<p>The only difference between cbrt and sqrt is the <strong>improve</strong> procedure.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Coursera online functional programming course - a retrospective]]></title>
    <link href="http://chuchao333.github.com/blog/2013/01/06/coursera-online-functional-programming-course-review/"/>
    <updated>2013-01-06T15:52:00+08:00</updated>
    <id>http://chuchao333.github.com/blog/2013/01/06/coursera-online-functional-programming-course-review</id>
    <content type="html"><![CDATA[<p>Here comes the summary of the Coursera course
<code>Fucntional Programming Principles in Scala &lt;https://class.coursera.org/progfun-2012-001/class/index&gt;</code>_
It’s a little bit late, it has been two months since I finished the course.
This is the first Coursera course I followed from the very beginning to the end
and accomplished all the programming assignments with full scores, which helped
me to get the certificate with distinction.</p>

<p>.. image:: /images/posts/coursera_scala_certificate.jpg</p>

<p>First the excellent parts of the course:</p>

<ul>
  <li>Martin Odersky is a pretty good teacher, and all the lectures are well
designed. I enjoyed watching the lectures a lot and most of which I have
read more than once.</li>
  <li>The programming assignments are well structured, with detailed instructions
and step by step guide. In each of the assignments, the whole task is split
into several steps with approprivate level of abstractions.</li>
  <li>There are also many useful supporting materials like scala style guide, sbt
tutorial, instructions on tools setup for the course, which made it easier
to concentrate on the course content. For me, I don’t have scala develop
environment setup before the course, and by following the tools setup section
in only took me less than half an hour to get everything ready for trying the
example code and the assignments.</li>
</ul>

<p>As for the less-good things, I would say:</p>

<ul>
  <li>Both the lectures and the assignments are quite easy for an experienced
programmers (No functional programming background needed), I was expecting
more challenging stuff.</li>
  <li>There are no official solutions distributed. (The course will be offered
again some time later) However, I still think for those students who passed
the course should be qualified to get the solutions so that they can compare
those with their own to see where they can still improve.</li>
  <li>It’s a pity that this is only the first half of an advanced undergraduate
course that Martin taught on campus. I am interested in the other half.</li>
</ul>

<p>After taking this cousre, I got a deeper understanding of the functional
programming basics and it made me feel more comfortable while picking up
SICP again (after 3 years). Now, I am convinced that I am able to go through
SICP and finish most of the exercises. Also, I had a firmer grasp of Scala
even though I didn’t write more than 100 lines of Scala before; I understand
more about the scala syntax, idioms and even the motivations behind some of the
language structures. E.g., call by name/value, lazy evaluation, currying,
pattern matching and so on. I will publish my detailed notes on the lectures
and assignments to this blog later.</p>

<p>To conclude, I really enjoyed taking the course and many thanks to Martin
, the TAs, and also the coursera staff for offering such a wonderful course.</p>
]]></content>
  </entry>
  
</feed>
